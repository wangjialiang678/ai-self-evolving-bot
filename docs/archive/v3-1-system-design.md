# 自进化智能体系统：完整设计 v3.1

> **版本**: v3.1  
> **日期**: 2026-02-22  
> **前序版本**: v3.0（架构总纲 + 运行哲学）  
> **本版核心变化**:  
> 1. 融入 Evolver/昊阳/胡渊鸣三篇文章的启发  
> 2. 确立"进化型 MVP"路线——系统从第一天就具备自我改进闭环  
> 3. 新增 Architect 智能体——专门负责系统自身迭代设计  
> 4. 以 NanoBot 为基座框架，明确技术栈选择  
> 5. 重新定义审批边界——不以"能不能改"划线，而以"什么修改需要人介入"划线  
> **配套文档**: [MVP 实施方案](doc2_mvp_plan.md) | [附录：规则模板与示例](doc3_appendix.md)

---

## 一、设计背景与思想来源

### 1.1 从三篇文章中提炼的核心洞察

**昊阳 / Evolver 的启示：进化循环可以不需要人**

昊阳将 AI 使用方式分为三个阶段：人让 AI 帮人写 → AI 自己给自己写 → AI 写给其他 AI 用。最核心的贡献不在于 Evolver 的具体实现，而在于他用四段自然语言提示词就启动了整个进化过程——这从实战角度验证了"规则即程序"的可行性。他的"原初进化之火"本质上就是一组规则文件，龙虾读了这些规则之后自主执行了进化行为。

更深层的启发是关于**文化基因**：每个 Agent 都是"文化上的孤儿"——一个 Agent 积累的经验不会自动传递给另一个 Agent。Agent 间不存在继承机制。GEP 协议的核心设计"因地制宜"——基因不是照搬的，新 Agent 根据自身环境与原始环境的差异决定表达哪些基因、不表达哪些——这为我们的记忆系统设计提供了重要参考。

**Evolver 技术分析的启示：协议约束下的安全进化**

Evolver 最有价值的工程智慧包括：
- **信号驱动进化**：不是定时触发，而是从运行时日志中提取信号（错误、机会、元信号）来驱动进化方向
- **策略预设 + 自动切换**：六种策略（balanced / innovate / harden / repair-only / early-stabilize / steady-state）根据系统状态自动切换
- **爆炸半径控制**：不限制进化方向，但限制单次进化的影响范围（60 文件 / 20000 行硬上限）
- **停滞检测 + 强制创新**：连续空转时自动切换到创新模式
- **遗传漂变**（`1/√Ne`）：小基因池时增加随机性，防止局部最优
- **回滚机制**：每次进化保留上一稳定版本，失败自动回滚

我们不照搬 Evolver 的具体实现（性格系统、完整 GEP 协议对 MVP 来说太重了），但这些工程原则直接指导我们的安全进化设计。

**胡渊鸣的启示：从人管 AI 到人给 AI 打工**

胡渊鸣展示了一个从"手动操控"到"只提供上下文和方向"的渐进式转变过程：
- **"Context, not control"**——不告诉 AI 怎么做，而是给足够上下文让它自己判断
- **CLAUDE.md（稳定规则）+ PROGRESS.md（经验积累）双文件模式**——这个模式被实践验证有效，直接映射到我们的"宪法级规则 + 经验级规则"设计
- **用 AI 管理 AI 的真实困难**——"Claude Code 并不擅长管理其他 Claude Code，就像 IC 天生不一定是好经理"。成功率从 20% 到 95% 花了不少功夫。这提醒我们：观察者和 Architect 管理系统不是理所当然的事
- **闭环反馈是一切的基础**——"只要能在闭环环境中让 AI 端到端获得反馈的任务，都是简单的任务"

### 1.2 Michael 的核心决策（本版输入）

基于前文分析和讨论，Michael 确认了以下关键设计决策：

| 决策项 | 选择 | 理由 |
|--------|------|------|
| 观察者权限 | A（保守）：只观察、记录、建议 | 先积累信任，逐步放权 |
| 进化节奏 | C（混合）：轻量反思 + 信号触发深度分析 | 平衡成本和灵敏度 |
| 技术载体 | Python + NanoBot 框架 + Web Dashboard | NanoBot 轻量、可控、研究友好 |
| 文化基因 | MVP 不做，但预留接口 | 架构上确保记忆可导出可共享 |
| 系统迭代 | 独立 Architect 智能体负责 | 观察者积累数据，Architect 设计方案 |
| 修改边界 | 不以"能不能改"划线 | 而以"什么修改需要人审批"划线 |
| 与 Claude Code 关系 | 独立系统，但可参考设计、未来可调用 | 不依赖特定工具链 |

### 1.3 版本演进脉络

```
v1.0：最初构思
  → 反思引擎 + 进化引擎 + 好奇心引擎的概念提出

v2.1：系统架构
  → 三层架构 + 十大组件 + CODER 角色 + 难度路由
  → 问题：骨架本身是硬编码的，进化只发生在薄薄的策略层

v3.0：范式转变
  → 四层架构：硬核层 + 规则层 + 认知层 + 自我定义层
  → 核心转变：规则即程序，代码即基座
  → 新增：观察者智能体、自主运行引擎、主动提问机制

v3.1：本版 ← 你在这里
  → 融入实战启发（Evolver、胡渊鸣工作流）
  → "进化型 MVP"路线——从第一天就具备自我改进闭环
  → 新增 Architect 智能体——分离"观察积累"和"设计修改"
  → 明确 NanoBot 技术基座
  → 信号驱动 + 爆炸半径 + 策略自适应等工程机制
  → 审批边界重新定义
```

---

## 二、系统架构总览

### 2.1 架构全景

v3.1 在 v3.0 四层模型的基础上，做了以下关键调整：

1. 自我定义层拆分为两个角色：**Observer（观察者）** 和 **Architect（架构师）**
2. 引入**信号系统**作为进化的触发机制
3. 引入**审批分级**替代简单的"硬编码 vs 可修改"二分法
4. 明确以 **NanoBot** 为基座框架

```
┌─────────────────────────────────────────────────────────────────┐
│                      系统自治层                                    │
│              (System Autonomy Layer)                              │
│                                                                  │
│  ┌──────────────┐    信号流     ┌──────────────┐                 │
│  │   Observer    │ ──────────→ │  Architect    │                 │
│  │   观察者       │  观察笔记 +  │  架构师        │                 │
│  │              │  信号报告     │              │                 │
│  │ 职责：        │             │ 职责：        │                 │
│  │ · 监听一切    │             │ · 设计改进方案  │                 │
│  │ · 记录数据    │             │ · 编写设计文档  │                 │
│  │ · 提取信号    │             │ · 和人沟通确认  │                 │
│  │ · 标记发现    │             │ · 执行已批准修改 │                 │
│  │              │             │ · 验证修改效果  │                 │
│  │ 不做修改      │             │              │                 │
│  └──────────────┘             └──────────────┘                 │
│         ↑ 全局可见                    ↑ 继承 Observer 上下文       │
├─────────────────────────────────────────────────────────────────┤
│                      规则层                                       │
│              (Rule Layer) ← 系统的灵魂                            │
│                                                                  │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │                                                          │   │
│  │  宪法级规则（Constitutional Rules）                        │   │
│  │  ├── 安全边界规则                                         │   │
│  │  ├── 审批分级规则                                         │   │
│  │  ├── 核心编排逻辑                                         │   │
│  │  └── 元规则（规则如何被修改的规则）                          │   │
│  │                                                          │   │
│  │  经验级规则（Experience Rules）                            │   │
│  │  ├── 任务执行策略                                         │   │
│  │  ├── 反思模板与维度                                       │   │
│  │  ├── 记忆存取策略                                         │   │
│  │  ├── 交互与提问策略                                       │   │
│  │  └── 不断积累的经验教训                                    │   │
│  │                                                          │   │
│  └──────────────────────────────────────────────────────────┘   │
│                                                                  │
├─────────────────────────────────────────────────────────────────┤
│                      认知层                                       │
│              (Cognition Layer)                                    │
│                                                                  │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────────────┐  │
│  │  上下文引擎    │  │   记忆系统    │  │   信号系统            │  │
│  │  Context      │  │   Memory     │  │   Signal System      │  │
│  │  Engine       │  │   System     │  │   (v3.1 新增)        │  │
│  └──────────────┘  └──────────────┘  └──────────────────────┘  │
│                                                                  │
│  职责：上下文组装、信息持久化与检索、信号提取与路由                    │
├─────────────────────────────────────────────────────────────────┤
│                      执行层                                       │
│              (Execution Layer)                                    │
│                                                                  │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────────────┐  │
│  │  NanoBot 核心  │  │   工具系统    │  │   通信通道            │  │
│  │  Agent Loop   │  │   Skill      │  │   Channels           │  │
│  │  + Message Bus│  │   System     │  │   (Telegram/Web等)   │  │
│  └──────────────┘  └──────────────┘  └──────────────────────┘  │
│                                                                  │
│  职责：任务执行、工具调用、消息路由                                   │
├─────────────────────────────────────────────────────────────────┤
│                      硬核层                                       │
│              (Hard Core — 代码实现)                                │
│                                                                  │
│  NanoBot 框架代码 + 我们的扩展代码                                  │
│  ├── 规则解释器（读取规则文件 → 组装 prompt → 调用 LLM）            │
│  ├── LLM 网关（Opus / Gemini / 其他模型路由）                      │
│  ├── 信号检测器（从日志和执行轨迹中提取信号）                        │
│  ├── 文件系统接口（读写规则文件、记忆文件、日志文件）                  │
│  ├── Web Dashboard 服务（展示系统状态和关键数据）                    │
│  └── 安全沙盒（限制 Agent 的文件和网络访问范围）                     │
│                                                                  │
│  这一层是唯一不能被 Agent 修改的部分（但 Architect 可以提出修改建议）  │
└─────────────────────────────────────────────────────────────────┘
```

### 2.2 与 NanoBot 的关系

NanoBot（HKU Data Intelligence Lab 的开源项目）是我们的基座框架。选择它的原因：

```
为什么选 NanoBot：
  · 极轻量：~4000 行 Python，可在几小时内通读全部代码
  · 架构清晰：Agent Loop + Memory + Skills + Message Bus 四模块
  · 多通道支持：Telegram / WhatsApp / Discord / Feishu / Web
  · 多 LLM 支持：Anthropic / Google / OpenAI / OpenRouter
  · 研究友好：代码可读可改，没有过度抽象
  · MCP 支持：可接入外部工具生态
  · 活跃维护：2026 年 2 月持续更新

我们在 NanoBot 上做什么：
  · 保留：Agent Loop、Message Bus、Channel 管理、Provider Registry
  · 替换：Memory 系统（用我们的分级记忆替换简单记忆）
  · 新增：规则解释器、信号系统、Observer、Architect、Web Dashboard
  · 扩展：上下文引擎（替换简单的 ContextBuilder）

关键原则：
  · 不 fork NanoBot，而是作为扩展/插件的形式构建
  · 尽量不修改 NanoBot 核心代码，通过 hook 和覆写实现定制
  · 这样可以持续跟进 NanoBot 的上游更新
```

### 2.3 LLM 配置策略

系统使用双模型架构，充分利用不同模型的优势：

```
Claude Opus（主力模型）：
  · 核心推理：任务规划、复杂决策、代码生成
  · Observer 分析：需要深度理解的观察和判断
  · Architect 设计：系统改进方案的设计和文档编写
  · 选择理由：推理能力最强，适合需要深度思考的场景

Gemini（辅助模型）：
  · 轻量反思：每次任务后的快速复盘
  · 信号检测：日志扫描和模式识别
  · 信息检索：网络搜索和资料整理
  · 记忆压缩：对话摘要和信息提取
  · 选择理由：成本更低，长上下文支持，适合大量低密度推理

模型路由规则（写在规则文件中，可被 Architect 调整）：
  · 需要深度推理的任务 → Opus
  · 批量处理和模式识别 → Gemini
  · 成本敏感的高频操作 → Gemini
  · 不确定时 → 默认 Opus
```

---

## 三、核心智能体设计

### 3.1 Observer（观察者）

Observer 是系统的"眼睛和耳朵"。它看到一切，记录一切，但自己不做任何修改。

```
身份定位：
  Observer 是一个独立的、有"上帝视角"的智能体。
  它能看到系统中所有 Agent 的交互记录、所有任务的执行轨迹、
  所有规则文件的内容和变更历史、所有用户的反馈。
  
  但它只做三件事：
  1. 观察和记录
  2. 提取信号
  3. 生成观察笔记

  它不会修改任何规则、不会直接执行任何改进。
  它把所有发现交给 Architect 去处理。
```

**Observer 的运行模式（混合式：轻量 + 信号触发）**：

```
轻量模式（每次任务后自动触发）：
  成本：几百 token（使用 Gemini）
  耗时：几秒
  做什么：
    - 读取本次任务的执行轨迹
    - 快速判断：成功/部分成功/失败
    - 记录关键数据点（耗时、token 消耗、工具调用次数）
    - 检测简单信号（是否出错、是否超时、用户是否不满）
    - 写一条简短的观察日志

深度模式（信号触发）：
  成本：数千 token（使用 Opus）
  耗时：数十秒到一分钟
  触发条件：
    - 连续 3 次任务失败
    - 用户明确表达不满
    - 检测到重复错误模式
    - 进化停滞（连续 N 次轻量观察没有发现新信号）
    - 达到时间阈值（如每天至少一次深度分析）
  做什么：
    - 读取近期所有任务轨迹
    - 对比规则预期 vs 实际效果
    - 识别模式：哪些规则有效、哪些无效、哪些缺失
    - 生成结构化观察报告
    - 将报告推送给 Architect
```

**Observer 输出格式**：

```
轻量观察日志（每次任务后）：
  timestamp: 2026-02-22T10:15:00
  task_id: task_001
  outcome: SUCCESS / PARTIAL / FAILURE
  duration_sec: 45
  tokens_used: 3200
  model_used: opus
  signals_detected: []
  one_line_note: "用户问了竞品分析，系统成功完成，但用户追问了两次才得到满意答案"

深度观察报告（信号触发时）：
  timestamp: 2026-02-22T23:00:00
  trigger: "daily_review"
  period_covered: "2026-02-22 全天"
  tasks_analyzed: 12
  
  findings:
    - finding: "规则 orchestration_basic.md 中的任务分解策略被用了 8 次，其中 6 次效果好"
      confidence: high
      signal: rule_validated
      
    - finding: "用户在 3 次对话中反复纠正格式问题，现有规则未覆盖格式偏好"
      confidence: high
      signal: rule_gap_detected
      
    - finding: "记忆检索在 2 次任务中未能找到相关历史，但相关信息确实存在"
      confidence: medium
      signal: memory_retrieval_failure
      
  recommendations_for_architect:
    - "考虑新增格式偏好规则，从用户的纠正中提取偏好模式"
    - "记忆检索的关键词匹配策略可能需要调整"
```

### 3.2 Architect（架构师）

Architect 是系统的"总设计师"。它读取 Observer 的发现，设计改进方案，和用户沟通确认，然后执行修改。

```
身份定位：
  Architect 是系统进化的推动者。
  它继承 Observer 的所有上下文和记忆——
  看到系统里的所有对话记录、Observer 的所有观察笔记和信号报告。
  
  与 Observer 的关键区别：
    Observer = 眼睛和耳朵（感知，不行动）
    Architect = 大脑和双手（思考，并行动）
  
  它做的事：
  1. 读取 Observer 的发现和建议
  2. 结合 Big Picture（完整架构设计文档）分析
  3. 设计具体的修改方案
  4. 编写修改提案文档
  5. 与用户沟通确认（需要审批的修改）
  6. 执行已批准的修改
  7. 观察修改效果（通过后续 Observer 数据验证）

  Architect 作为独立项目运行，有自己的工作空间和记忆。
  它和主系统共享的是 Observer 的输出和系统的规则文件。
```

**Architect 的触发时机与频率**：

```
定时触发：
  · 每日一次（默认凌晨或用户设定的空闲时间）
    读取当日 Observer 的所有观察日志
    分析累积的信号
    决定是否需要提出改进方案

信号触发：
  · Observer 生成深度报告时 → Architect 被唤醒分析
  · 累积 N 个未处理的 medium/high 优先级信号时
  · 用户主动要求系统自检时

主动触发（Architect 自己决定）：
  · 上次设计的修改已经运行了足够长时间
    → 主动检查效果，决定是否需要调整
  · 发现 Big Picture 与实际运行出现偏差
    → 主动向用户沟通

不触发：
  · 系统运行正常、Observer 没有新的显著发现时
    → Architect 不做无意义的分析（避免空转）
  · 刚完成一次修改还在验证期时
    → 等待数据积累，不急于再改
```

**Architect 的工作流程**：

```
Phase 1：情报收集
  ├── 读取 Observer 近期所有观察笔记
  ├── 读取系统运行指标（任务成功率、用户满意度、token 消耗等）
  ├── 读取当前所有规则文件
  ├── 读取 Big Picture 设计文档
  └── 读取上次修改的效果评估

Phase 2：问题诊断
  ├── 哪些规则被证明有效？（保留和强化）
  ├── 哪些规则被证明无效或多余？（候选删除）
  ├── 哪些场景缺少规则覆盖？（候选新增）
  ├── 系统整体表现趋势如何？（上升/稳定/下降）
  └── 当前进化策略是否合适？（是否需要切换）

Phase 3：方案设计
  ├── 针对每个发现，设计具体修改方案
  ├── 评估每个方案的影响范围（爆炸半径）
  ├── 确定方案优先级
  ├── 判断每个方案需要的审批级别
  └── 编写修改提案文档

Phase 4：沟通确认
  ├── 需要审批的方案 → 主动发消息给用户，附带提案文档
  ├── 不需要审批的方案 → 记录后直接执行
  └── 不确定是否需要审批 → 默认需要审批（保守原则）

Phase 5：执行修改
  ├── 修改前备份当前状态
  ├── 执行修改（修改规则文件、调整配置等）
  ├── 标记修改为"验证中"
  └── 设定验证观察期（由修改类型决定长短）

Phase 6：效果验证
  ├── 在验证期内，Observer 持续收集数据
  ├── 验证期结束后，Architect 分析效果
  ├── 效果好 → 标记为"已验证有效"
  ├── 效果差 → 自动回滚到备份状态
  └── 效果不明确 → 延长验证期或设计更有针对性的测试
```

**Architect 与用户的沟通方式**：

```
Architect 通过系统的消息通道（如 Telegram）主动联系用户。
消息类型和频率控制：

重要提案（需要审批的修改）：
  · 立即发送，但控制频率不超过每天 2 条
  · 格式：简要说明发现 + 修改方案 + 预期效果 + 请求确认
  · 用户可以回复"同意"/"拒绝"/"稍后"/"需要讨论"

日报/周报：
  · 每日简报（可选开关）：今天的观察发现、修改执行情况
  · 每周汇总：本周系统进化总结、下周计划
  · 用户可以设定接收频率

效果报告：
  · 某个修改验证完成后，报告结果
  · "上周建议的格式规则已经运行 5 天，
     用户纠正格式的次数从平均每天 3 次下降到 0.5 次"

紧急通知：
  · 发现严重问题时立即通知
  · 如：系统任务成功率突然下降 30%
```

### 3.3 Observer 和 Architect 的关系

```
两个智能体的分工是清晰的：

Observer 像一个研究员 / 记者：
  · 深入一线，观察每一个细节
  · 忠实记录，不带预设立场
  · 提取信号，标记发现
  · 但不做设计决策

Architect 像一个总架构师 / CTO：
  · 读取研究员的报告
  · 结合全局视角做判断
  · 设计改进方案
  · 和老板（Michael）沟通确认
  · 推动修改落地

信息流向：
  系统运行 → Observer 记录 → Observer 提取信号 →
  信号累积 → 触发 Architect → Architect 分析 →
  Architect 设计方案 → 需要审批 → 用户确认 →
  Architect 执行修改 → Observer 继续观察效果

为什么不合并成一个智能体：
  1. 观察和设计是不同的思维模式，分开可以各自专注
  2. Observer 的运行频率远高于 Architect（每次任务 vs 每天/信号触发）
  3. Observer 使用低成本模型（Gemini），Architect 使用高能力模型（Opus）
  4. 分离后更容易审计——可以单独查看 Observer 的原始发现
  5. Architect 独立运行，即使主系统出问题，它的分析能力不受影响
```

---

## 四、规则系统设计

### 4.1 规则分类：宪法级 vs 经验级

受胡渊鸣 CLAUDE.md + PROGRESS.md 启发，规则文件明确分为两类：

```
宪法级规则（Constitutional Rules）：
  类比：CLAUDE.md——基本框架和原则，很少修改
  特征：
    · 定义系统的基本行为框架
    · 修改需要用户审批
    · 即使 Architect 也不能自主修改
    · 变更频率：低（周级或更低）
  
  包含：
    rules/
    ├── constitution/
    │   ├── safety_boundaries.md      # 安全边界
    │   ├── approval_levels.md        # 审批分级定义
    │   ├── meta_rules.md             # 规则如何被修改的规则
    │   ├── core_orchestration.md     # 核心编排逻辑
    │   └── identity.md               # 系统身份和基本人格

经验级规则（Experience Rules）：
  类比：PROGRESS.md——从实践中积累的经验教训，持续更新
  特征：
    · 从实际运行中学习和沉淀
    · 低风险修改可由 Architect 自主执行
    · 高风险修改仍需用户审批
    · 变更频率：高（日级或更高）
  
  包含：
    rules/
    ├── experience/
    │   ├── task_strategies.md         # 各类任务的执行策略
    │   ├── reflection_templates.md    # 反思的维度和模板
    │   ├── memory_strategies.md       # 记忆存取策略
    │   ├── interaction_patterns.md    # 用户交互模式
    │   ├── tool_usage_tips.md         # 工具使用技巧
    │   ├── error_patterns.md          # 常见错误及应对
    │   └── user_preferences.md        # 从用户行为中学到的偏好
```

### 4.2 审批分级机制

**核心理念转变**：不以"这个东西能不能被修改"划线，而以"这个修改需不需要人介入"划线。任何东西理论上都可以被修改，区别只在于审批流程。

```
Level 0：自由修改（Architect 自主执行，无需通知）
  · 经验规则中的措辞优化
  · 经验规则中新增具体示例
  · 反思模板的微调
  · 记忆标签和分类的调整
  · 修改条件：爆炸半径 ≤ 1 个规则文件，且不改变规则语义
  · 回滚保障：自动备份 + 3 天验证期

Level 1：先做后报（Architect 执行后通知用户）
  · 经验规则中新增一条策略
  · 修改任务执行的优先级排序
  · 调整记忆保留和过期策略
  · 调整模型路由规则（如 Opus/Gemini 的分工）
  · 修改条件：有 Observer 数据支撑，且有回滚方案
  · 回滚保障：自动备份 + 用户可以随时否决并回滚

Level 2：先报后做（Architect 提出方案，用户确认后执行）
  · 宪法级规则的任何修改
  · 新增或删除一整条经验规则
  · 修改编排逻辑（如任务分解策略）
  · 修改 Observer 或 Architect 自身的工作规则
  · 修改审批分级的定义
  · 影响范围较大的改动（爆炸半径 > 3 个文件）

Level 3：需要深入讨论（Architect 发起讨论，用户理解后决策）
  · 架构层面的调整（如新增一个 Agent 角色）
  · 安全边界的修改
  · 硬核层代码的修改建议
  · 系统运行模式的重大变化
  · Big Picture 设计文档的更新建议
```

### 4.3 进化策略自适应

借鉴 Evolver 的六种策略预设，但简化为更适合我们场景的四种：

```
策略预设（写在规则文件中，可被 Architect 调整）：

cautious（谨慎模式）：
  适用：系统刚启动、或刚做完重大修改
  行为：
    · 只修复明确的错误
    · 不做创新性改动
    · Observer 深度分析频率提高
    · Architect 所有修改都需要 Level 2 审批
  自动触发条件：系统运行前 7 天 / 重大修改后 3 天

balanced（平衡模式）：
  适用：系统稳定运行中
  行为：
    · 正常的修复 + 优化 + 小幅创新
    · 审批级别按正常分级执行
    · 默认模式

growth（增长模式）：
  适用：系统稳定且出现进化停滞
  行为：
    · 鼓励 Architect 提出更大胆的改进
    · Observer 增加对"机会信号"的关注
    · 允许更多 Level 0/1 的自主修改
  自动触发条件：连续 14 天没有显著改进

repair（修复模式）：
  适用：系统表现突然下降
  行为：
    · 暂停所有非修复类改动
    · Architect 聚焦诊断问题根因
    · 如果是最近修改导致 → 自动回滚
  自动触发条件：任务成功率下降 > 20% / 用户多次表达不满

策略切换规则：
  · 由 Architect 基于 Observer 数据建议
  · cautious → balanced 的切换需要用户确认
  · 其他切换可以 Architect 自主决定（Level 1）
  · 紧急切换到 repair 模式不需要等审批
```

---

## 五、信号系统设计

### 5.1 信号类型

信号是连接 Observer 和 Architect 的桥梁。Observer 从系统运行中提取信号，Architect 根据信号决定行动。

```
错误信号（驱动修复）：
  · task_failure          — 任务执行失败
  · repeated_error        — 同类错误反复出现（3+ 次）
  · user_correction       — 用户纠正系统输出
  · tool_failure          — 工具调用失败
  · timeout               — 任务执行超时

机会信号（驱动优化和创新）：
  · rule_validated        — 某条规则被多次验证有效
  · rule_unused           — 某条规则长期未被触发
  · user_pattern          — 检测到用户的新偏好模式
  · efficiency_opportunity — 发现可以减少步骤/token 的机会
  · capability_gap        — 用户需求超出当前规则覆盖范围

元信号（系统状态）：
  · evolution_stagnation  — 长时间没有有效的改进
  · performance_degradation — 系统表现持续下降
  · strategy_mismatch     — 当前策略与系统状态不匹配
  · architect_proposal_pending — Architect 有待处理的提案
  · modification_under_validation — 有修改正在验证期
```

### 5.2 信号处理流程

```
1. 信号提取（Observer 执行）：
   每次任务后的轻量检测 → 提取基本信号
   定期深度分析 → 提取模式级信号

2. 信号去重（自动）：
   同一信号在短时间内多次出现 → 合并为一个（计数+1）
   避免同一问题反复触发 Architect

3. 信号优先级评估（Observer 标记）：
   low    → 记录但不立即触发 Architect
   medium → 累积到阈值后触发 Architect
   high   → 立即触发 Architect

4. 信号消费（Architect 处理）：
   Architect 读取未处理的信号 → 分析 → 设计方案 → 标记为已处理
   处理后的信号进入历史归档
```

---

## 六、记忆系统设计

### 6.1 MVP 阶段的简化记忆

MVP 阶段不做复杂的向量检索和分级记忆，而是用最简单的文件系统实现：

```
memory/
├── MEMORY.md                    # 核心记忆（类比 CLAUDE.md 的 PROGRESS.md）
│                                # 结构化的重要信息汇总
│                                # 由 Observer 和系统自动维护
│
├── conversations/               # 完整对话记录
│   ├── 2026-02-22/
│   │   ├── conv_001.jsonl       # 对话轨迹（每行一条消息）
│   │   ├── conv_002.jsonl
│   │   └── daily_summary.md     # 当日对话摘要
│   └── ...
│
├── observations/                # Observer 的观察记录
│   ├── lightweight/             # 轻量观察日志
│   │   └── 2026-02-22.jsonl     # 每次任务的简短记录
│   └── deep/                    # 深度观察报告
│       └── report_2026-02-22.md
│
├── architect/                   # Architect 的工作文件
│   ├── proposals/               # 修改提案
│   │   ├── prop_001.md
│   │   └── prop_002.md
│   ├── modifications/           # 已执行的修改记录
│   │   └── mod_001.md           # 包含：修改内容、原因、效果
│   └── architect_memory.md      # Architect 的长期记忆
│
├── signals/                     # 信号记录
│   ├── active.jsonl             # 未处理的信号
│   └── archive.jsonl            # 已处理的信号归档
│
└── backups/                     # 规则文件的备份
    └── 2026-02-22T10-00-00/     # 每次修改前的快照
        ├── rules/               # 完整规则文件副本
        └── metadata.json        # 修改原因、触发信号等
```

### 6.2 MEMORY.md 的结构

```markdown
# System Memory

## User Profile
- 名字：Michael
- 工作：SuperBrain AI 教育
- 技术栈偏好：Python、极简代码
- 沟通偏好：（从交互中逐步学习）
- 其他偏好：（持续积累）

## Validated Strategies
（经过验证有效的策略，从反思中沉淀）
- [2026-02-22] 用户偏好在代码问题上先给方案再解释
- [2026-02-23] 竞品分析任务最好先问清楚对比维度

## Known Issues
（已知但未解决的问题）
- [2026-02-22] 记忆检索在长对话中偶尔检索不到相关历史

## Error Patterns
（常见错误模式及应对）
- [2026-02-22] 当用户说"简单点"时不要输出长篇大论

## Evolution Log
（系统进化的关键里程碑）
- [2026-02-22] 系统初始化，进入 cautious 策略
- [2026-02-25] 切换到 balanced 策略
```

### 6.3 未来的记忆升级路径（MVP 后由 Architect 推动）

```
Phase 1（MVP）：纯文件系统
  · Markdown + JSONL
  · 检索靠关键词匹配和时间排序
  · 简单但可用

Phase 2（Architect 提案后实施）：引入向量搜索
  · sqlite-vec 或类似轻量向量库
  · 关键记忆做向量索引
  · 混合检索（关键词 + 语义）

Phase 3（更远期）：分级记忆
  · 按 v3.0 设计的五级记忆层次
  · 活跃记忆 → 工作记忆 → 长期记忆 → 归档
  · 主动遗忘和压缩机制

重要原则：记忆格式从 MVP 起就是可导出、可共享的。
使用标准的 Markdown 和 JSON，不依赖特定数据库格式。
为未来可能的跨系统经验继承预留可能性。
```

---

## 七、爆炸半径控制机制

借鉴 Evolver 的核心安全设计：

```
原则：不限制进化方向，但限制单次进化的影响范围。

规则文件修改：
  · 每次修改最多影响 1 个规则文件（Level 0）
  · 影响 2-3 个文件需要 Level 1
  · 影响 3+ 个文件需要 Level 2

配置修改：
  · 模型路由调整：每次只改一条路由规则
  · 工具配置：每次只改一个工具的配置

回滚机制：
  · 每次修改前自动备份完整的规则状态
  · 备份保留至少 30 天
  · 发现问题时一键回滚到任意备份点
  · Architect 可以自动回滚（不需要等人）

验证期：
  · Level 0 修改：3 天验证期
  · Level 1 修改：5 天验证期
  · Level 2 修改：7 天验证期
  · 验证期内 Observer 加强对相关指标的监控
  · 如果验证期内指标恶化 → 自动回滚
```

---

## 八、人机交互设计

### 8.1 交互通道

```
主通道：Telegram（通过 NanoBot 的 Channel 系统）
  · 用户日常对话的主入口
  · Architect 主动沟通的出口
  · 系统通知和报告的推送通道
  · 支持语音输入（NanoBot + Groq Whisper）

辅助通道：Web Dashboard
  · 展示系统状态和关键指标
  · 浏览 Observer 观察日志
  · 查看 Architect 提案和修改历史
  · 浏览规则文件（只读，修改通过 Architect 提案）
  · 查看信号列表和处理状态
  · 系统健康度面板

关键设计：AI 可以主动向人发消息
  · NanoBot 原生支持通过 Telegram Bot 主动发消息
  · Architect 的提案和报告通过此机制推送
  · 频率控制：通过规则文件配置最大推送频率
  · 用户可以设置"勿扰时段"
```

### 8.2 Web Dashboard 核心视图

```
Dashboard 首页：
  ┌──────────────────────────────────────────────┐
  │  系统健康度：🟢 正常  |  进化策略：balanced     │
  │  今日任务：12 完成 / 1 失败  |  活跃信号：3      │
  ├──────────────────────────────────────────────┤
  │                                              │
  │  📊 最近 7 天趋势                              │
  │  ┌────────────────────────────────────────┐  │
  │  │  任务成功率：85% → 90% ↑               │  │
  │  │  平均响应质量：7.2 → 7.8 ↑             │  │
  │  │  Token 消耗/任务：3.2k → 2.8k ↓        │  │
  │  │  用户纠正次数：5 → 2 ↓                  │  │
  │  └────────────────────────────────────────┘  │
  │                                              │
  │  📝 最近 Observer 发现                         │
  │  · [high] 记忆检索失败模式（已推送 Architect）   │
  │  · [medium] 规则 task_strategies 中有冗余条目   │
  │  · [low] 用户偏好中英文混排                     │
  │                                              │
  │  🔧 Architect 状态                             │
  │  · 待审批提案：1                               │
  │  · 验证中修改：2                               │
  │  · 本周已完成修改：3                            │
  │                                              │
  │  📜 规则文件概览                                │
  │  · 宪法级：5 个文件，上次修改 3 天前             │
  │  · 经验级：7 个文件，上次修改 今天              │
  │                                              │
  └──────────────────────────────────────────────┘
```

---

## 九、运行环境

```
硬件：
  · Michael 的 Mac（24 小时开机）
  · 足够运行 Python + NanoBot + SQLite

软件栈：
  · Python 3.11+
  · NanoBot（pip install nanobot-ai）
  · Flask/FastAPI（Web Dashboard）
  · SQLite（轻量数据存储）
  · Markdown/YAML/JSONL（规则和记忆文件）

外部服务：
  · Anthropic API（Claude Opus）
  · Google AI API（Gemini）
  · Telegram Bot API（消息通道）
  · Brave Search API（网络搜索，可选）

不使用：
  · Docker（开发期不需要）
  · 外部数据库（SQLite 就够）
  · LangChain / LlamaIndex（太重）
  · 云服务（全部本地运行）
```

---

## 十、设计原则总结

从 v2.1 的 9 条 + v3.0 的 3 条，到 v3.1 新增 3 条，共 15 条设计原则：

```
[v2.1 保留]
  P1:  两层智能（LLM 推理 + 认知架构增强）
  P2:  上下文即注意力（精心组装比简单堆叠更重要）
  P3:  记忆驱动进化（系统通过记忆变得更好）
  P4:  反思是第一推动力
  P5:  工具是能力的延伸
  P6:  透明可审计
  P7:  人类监督回路
  P8:  最小可行 + 渐进复杂
  P9:  本地优先、隐私优先

[v3.0 新增]
  P10: 规则即程序，代码即基座
  P11: 自我定义优于外部定义
  P12: 像积极主动的同事一样工作

[v3.1 新增]
  P13: 信号驱动，非时间驱动
       （进化不按固定时间表，而是对信号做出响应）
  P14: 爆炸半径优于权限控制
       （安全不靠"禁止修改"，而靠"限制单次修改的范围 + 自动回滚"）
  P15: 分离观察与行动
       （Observer 只感知，Architect 才行动，保证感知的客观性）
```

---

> **下一份文档**: [MVP 实施方案与自我迭代蓝图](doc2_mvp_plan.md)
