# Anthropic「Effective Harnesses for Long-Running Agents」文章解读与项目关联分析

> **来源**: https://www.anthropic.com/engineering/effective-harnesses-for-long-running-agents
> **日期**: 2026-02-24
> **分析者**: AI 自进化系统项目

---

## 一、文章核心内容

### 1.1 解决什么问题

长时间运行的 AI Agent 面临一个根本挑战：**跨上下文窗口的连续性问题**。每个新 session 启动时，模型对之前的工作一无所知——就像"轮班工程师交接，但新来的人没有任何交接记录"。

核心矛盾：LLM 是无状态的，但持续性任务需要状态。

### 1.2 两阶段 Agent 架构

Anthropic 提出了双 Agent 方案：

**Initializer Agent（初始化 Agent，首次运行）**

| 职责 | 产出物 |
|------|--------|
| 创建开发环境启动脚本 | `init.sh` |
| 记录工作进度 | `claude-progress.txt` |
| 建立版本控制基线 | Git 初始 commit |
| 生成全量特性列表 | 200+ 项 Feature List（JSON） |

**Coding Agent（编码 Agent，后续每次 session）**

| 步骤 | 说明 |
|------|------|
| 1. 确认工作目录 | `pwd` |
| 2. 读取历史 | git log + progress 文件 |
| 3. 选择目标 | 最高优先级的未完成 feature |
| 4. 启动环境 | 执行 `init.sh` |
| 5. 基线测试 | 先跑已有功能的测试 |
| 6. 增量实现 | 单 feature 实现 |
| 7. 提交并记录 | git commit + 更新 progress |

### 1.3 关键设计模式

#### 模式一：Feature List 作为进度锚点

- JSON 格式，200+ 项端到端特性描述
- 每项包含描述、步骤、`passes` 字段（初始为 false）
- **Agent 只能修改 `passes` 字段，不能删除或编辑测试本身**
- 防止 Agent "自己给自己改卷"导致功能遗漏

#### 模式二：增量进步协议

- 每个 session 只做一个 feature
- 防止 Agent "one-shot 整个应用"导致上下文耗尽、半成品无记录
- Git 集成允许回滚失败的修改

#### 模式三：自我验证

- 引入浏览器自动化（Puppeteer MCP）做端到端验证
- Agent 能像人类用户一样截图、点击、交互，发现代码审查看不到的 bug
- 没有自我验证时，Agent 倾向于自欺欺人——标记 feature 完成但实际没跑通

### 1.4 典型失败模式与对策

| 失败模式 | 本质原因 | Initializer 对策 | Coding Agent 对策 |
|----------|---------|------------------|-------------------|
| 过早宣称完成 | 缺乏明确完成标准 | 创建 Feature List | 按 feature 逐个攻克 |
| 进度无记录 | 无持久化机制 | 初始化 git + progress 文件 | 每次读历史、写 commit |
| 功能标记完成但实际没测 | 缺乏验证手段 | 建立 Feature List | 浏览器自动化自我验证 |
| 浪费时间在环境配置 | 重复劳动 | 写 init.sh 脚本 | 每次启动先执行 init.sh |

### 1.5 开放问题

- 单一通用 Agent vs 多专业 Agent（测试 Agent、QA Agent、代码清理 Agent）哪个更优？
- 该方法能否从 Web 开发推广到科学研究、金融建模等领域？
- 多 Agent 架构在跨上下文边界的表现如何？

---

## 二、文章的底层工作原理

### 2.1 核心思想：用文件系统弥补 LLM 的无状态缺陷

```
LLM 的缺陷           →  文件系统的补偿
─────────────────────────────────────────
无跨 session 记忆     →  progress.txt + git log
容易过早宣称完成      →  Feature List 作为外部锚点
容易在长任务中迷失    →  每 session 只做一个 feature
无法自我验证          →  浏览器自动化提供真实反馈
环境状态丢失          →  init.sh 脚本恢复环境
```

**本质是一个"外部认知脚手架"** — 用磁盘上的文件和脚本来补偿 LLM 的认知缺陷，让多个无状态的 LLM session 表现得像一个有状态的持续开发者。

### 2.2 反馈闭环结构

```
Feature List（目标）
      ↓
Coding Agent 选择一个 feature
      ↓
增量实现 + Git Commit
      ↓
浏览器自动化验证
      ↓
通过 → 标记 passes=true → 更新 progress
失败 → 修 bug → 重新验证
      ↓
下一个 session 继续
```

这是一个**数据驱动的闭环**：Feature List 提供目标，验证提供反馈，progress 提供记忆，Git 提供回滚能力。

---

## 三、与自进化智能体系统的关联分析

### 3.1 共享的核心理念

| 共享理念 | Anthropic 文章 | 我们的 V3.2 设计 |
|----------|---------------|-----------------|
| **文件系统即记忆** | progress.txt + git log 作为跨 session 记忆 | P4 原则：文件系统即认知虚拟内存，规则/记忆/日志以文件存储 |
| **外部锚点防漂移** | Feature List 防止 Agent 偏离目标 | 任务锚点（§5.3.2）：在上下文中复述当前任务和进度 |
| **增量进步** | 每 session 只做一个 feature | P15 最小复杂度原则 + 分步执行策略 |
| **自我验证** | Puppeteer MCP 做 E2E 测试 | P14 尽早被现实检验 + 验证基准体系 |
| **失败容忍 + 回滚** | Git commit 支持回滚失败修改 | P9 爆炸半径控制 + 自动回滚机制 |
| **可读的进度记录** | claude-progress.txt 人类可读 | P16 透明可审计原则 |

### 3.2 关键差异

| 维度 | Anthropic 方案 | 我们的设计 | 差异本质 |
|------|---------------|-----------|---------|
| **目标** | 跨 session 持续编码 | 自我进化的智能体 | 他们解决"连续性"，我们解决"成长性" |
| **进化能力** | 无 — Agent 不改变自身行为 | 核心 — Observer + Architect 驱动自我改进 | 最根本的区别 |
| **反馈来源** | Feature List（外部预定义） | 信号系统（从运行数据中自发现） | 他们是封闭目标集，我们是开放信号源 |
| **记忆层次** | 单层（progress + git） | 四层（工作/情节/语义/程序性） | 我们的记忆系统远更复杂 |
| **Agent 数量** | 2 个固定角色 | 多角色分离（Observer/Architect/审议会） | 我们关注分权和制衡 |
| **规则系统** | 硬编码在 prompt 中 | 可进化的分级规则文件 | 他们的 prompt 不变，我们的规则会进化 |
| **适用场景** | 全栈 Web 开发 | 通用智能体（对话/任务/自我管理） | 领域不同 |

### 3.3 可以借鉴的具体技术

#### 借鉴 1：init.sh 模式 → Bootstrap 增强

Anthropic 的 `init.sh` 理念与我们的 Bootstrap 流程高度对应。可借鉴的改进：

- **当前**：Bootstrap 已实现 3 阶段用户引导
- **可改进**：像 init.sh 一样，生成一个标准化的"系统状态恢复脚本"，每次新 session 自动执行，确保认知层、规则层的状态一致性恢复

#### 借鉴 2：Feature List 模式 → 信号系统增强

Feature List 的核心价值是"外部不可篡改的目标锚点"。对我们的启发：

- Observer 的观察笔记可以借鉴这种结构化格式
- 进化提案（Architect 生成）应有类似 Feature List 的 checklist，防止 Architect 自己标记"改进完成"但实际没验证

#### 借鉴 3：增量 + Git 回滚 → Architect 修改策略

- 当前设计已有爆炸半径控制和回滚机制
- 可强化：Architect 每次修改严格限制为"一个独立改进点"，类比"一个 session 一个 feature"
- 每次修改必须有 git commit，回滚粒度精确到单个改进

#### 借鉴 4：浏览器自动化验证 → 端到端验证闭环

- 当前设计的验证主要靠 Architect 自评 + 数据指标
- 可补充：引入端到端的"行为验证"——修改规则后，模拟一组典型任务，用数据证明改进有效
- 这对应文章中"Agent 倾向于自欺欺人"的教训

### 3.4 文章验证了我们的设计假设

| 我们的设计假设 | 文章中的实践验证 |
|---------------|----------------|
| P4: 文件系统即虚拟内存 | progress.txt + git 是跨 session 认知的唯一载体 |
| P3: 拥抱不完美，设计补偿机制 | 所有设计都在补偿 LLM 的"遗忘/自欺/漂移"缺陷 |
| P13: 失败是学习素材 | 失败模式表直接来自真实观察的 Agent 失败案例 |
| P8: 分离观察与行动 | Initializer（定义标准）和 Coding Agent（执行）的分离 |
| P7: 信号驱动 | Feature List 的 passes 字段就是一种"完成信号" |

### 3.5 文章暴露的问题，我们已有解决方案

| 文章的开放问题 | 我们的设计方案 |
|---------------|--------------|
| 单 Agent vs 多 Agent 哪个更好？ | V3.2 明确选择多角色分离：Observer 纯观察、Architect 设计执行、审议会讨论 |
| Agent 是否能自我改进？ | 这是我们的核心目标 — 整个进化闭环就是为此设计 |
| 跨领域泛化？ | 规则即程序的设计天然支持领域迁移 — 改规则文件就换领域 |

---

## 四、总结：一张对照图

```
Anthropic 方案（连续性问题的工程解法）
┌──────────────────────────────┐
│  Feature List  → 目标锚点    │
│  progress.txt  → 进度记忆    │
│  init.sh       → 环境恢复    │
│  Git           → 版本回滚    │
│  Puppeteer     → 自我验证    │
│  单 feature    → 增量执行    │
└──────────────────────────────┘
         ↓ 对应关系 ↓
我们的设计（自进化问题的系统解法）
┌──────────────────────────────┐
│  规则文件      → 行为定义    │
│  四层记忆      → 多粒度记忆  │
│  Bootstrap     → 环境初始化  │
│  爆炸半径+回滚 → 安全进化    │
│  Observer      → 持续观察    │
│  信号系统      → 进化方向    │
│  Architect     → 设计+执行   │
│  审议会        → 多视角验证  │
│  反思引擎      → 经验提取    │
└──────────────────────────────┘
```

**一句话总结**：Anthropic 的文章解决的是"如何让无状态的 LLM 在多个 session 中保持连续性"，我们的系统在此基础上更进一步——不仅保持连续性，还要从连续的经验中自主进化。Anthropic 的方案是我们系统的一个子集：他们在执行层做的事（进度记忆、增量执行、回滚），我们的执行层也做；但我们额外有认知层（反思、信号、记忆）和自治层（Observer、Architect、审议会）来实现真正的自我进化。

---

## 五、可行动建议

1. **强化 session 恢复机制** — 借鉴 init.sh，为每次新对话设计一个标准化的"认知恢复流程"
2. **Architect 引入 Feature List 式验证** — 每个进化提案附带可验证的 checklist，防止自我评判偏差
3. **增加端到端行为验证** — 规则修改后，自动跑一组基准任务验证效果，不依赖 Architect 自评
4. **控制单次进化粒度** — 借鉴"一个 session 一个 feature"，Architect 每次只改一个独立改进点
